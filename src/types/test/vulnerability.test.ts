import * as assert from 'assert';
import { Vulnerability, vulnToMarkdownString, doesVulnPassFilter, vulnToColor, sortVulnerabilities } from '../vulnerability';

suite('Vulnerability Tests', () => {
    test('vulnToMarkdownString should return a valid MarkdownString', () => {
        const vuln: Vulnerability = {
            name: 'Test Vulnerability',
            severity: {
                value: 'High',
                sourceName: 'Test Source'
            },
            cvssScore: {
                value: {
                    version: '3.0',
                    score: 7.5,
                    vector: 'AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H'
                },
                sourceName: 'Test Source'
            },
            disclosureDate: '2022-01-01',
            exploitable: true,
            fixedInVersion: '1.0',
            publishDateByVendor: {
                'Vendor A': '2022-01-01',
                'Vendor B': '2022-01-02'
            }
        };

        const expectedMarkdown = `**Name**: Test Vulnerability\n\n` +
            `**Severity**: High\n\n` +
            `**CVSS Score**: 7.5\n\n` +
            `**Disclosure Date**: 2022-01-01\n\n` +
            `**Exploitable**: true\n\n` +
            `**Fixed In Version**: 1.0\n\n`;

        const markdownString = vulnToMarkdownString(vuln);
        assert.strictEqual(markdownString.value, expectedMarkdown);
    });

    test('doesVulnPassFilter should return true when no filters are provided', () => {
        const vuln: Vulnerability = {
            name: 'Test Vulnerability',
            severity: {
                value: 'High',
                sourceName: 'Test Source'
            },
            cvssScore: {
                value: {
                    version: '3.0',
                    score: 7.5,
                    vector: 'AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H'
                },
                sourceName: 'Test Source'
            },
            disclosureDate: '2022-01-01',
            exploitable: true,
            fixedInVersion: '1.0',
            publishDateByVendor: {
                'Vendor A': '2022-01-01',
                'Vendor B': '2022-01-02'
            }
        };

        const filters = new Set<string>();
        const result = doesVulnPassFilter(vuln, filters);
        assert.strictEqual(result, true);
    });

    test('vulnToColor should return the correct color for severity', () => {
        const criticalSeverity = 'Critical';
        const highSeverity = 'High';
        const mediumSeverity = 'Medium';
        const lowSeverity = 'Low';
        const negligibleSeverity = 'Negligible';

        const criticalColor = vulnToColor(criticalSeverity);
        const highColor = vulnToColor(highSeverity);
        const mediumColor = vulnToColor(mediumSeverity);
        const lowColor = vulnToColor(lowSeverity);
        const negligibleColor = vulnToColor(negligibleSeverity);

        assert.strictEqual(criticalColor, 'charts.purple');
        assert.strictEqual(highColor, 'charts.red');
        assert.strictEqual(mediumColor, 'charts.orange');
        assert.strictEqual(lowColor, 'charts.yellow');
        assert.strictEqual(negligibleColor, 'charts.foreground');
    });

    test('sortVulnerabilities should sort vulnerabilities by severity', () => {
        const vulnerabilities: Vulnerability[] = [
            {
                name: 'Vuln 1',
                severity: {
                    value: 'Medium',
                    sourceName: 'Test Source'
                },
                cvssScore: {
                    value: {
                        version: '3.0',
                        score: 5.0,
                        vector: 'AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H'
                    },
                    sourceName: 'Test Source'
                },
                disclosureDate: '2022-01-01',
                exploitable: true,
                fixedInVersion: '1.0',
                publishDateByVendor: {
                    'Vendor A': '2022-01-01',
                    'Vendor B': '2022-01-02'
                }
            },
            {
                name: 'Vuln 2',
                severity: {
                    value: 'High',
                    sourceName: 'Test Source'
                },
                cvssScore: {
                    value: {
                        version: '3.0',
                        score: 7.5,
                        vector: 'AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H'
                    },
                    sourceName: 'Test Source'
                },
                disclosureDate: '2022-01-01',
                exploitable: true,
                fixedInVersion: '1.0',
                publishDateByVendor: {
                    'Vendor A': '2022-01-01',
                    'Vendor B': '2022-01-02'
                }
            },
            {
                name: 'Vuln 3',
                severity: {
                    value: 'Low',
                    sourceName: 'Test Source'
                },
                cvssScore: {
                    value: {
                        version: '3.0',
                        score: 2.5,
                        vector: 'AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H'
                    },
                    sourceName: 'Test Source'
                },
                disclosureDate: '2022-01-01',
                exploitable: true,
                fixedInVersion: '1.0',
                publishDateByVendor: {
                    'Vendor A': '2022-01-01',
                    'Vendor B': '2022-01-02'
                }
            }
        ];

        const sortedVulnerabilities = sortVulnerabilities(vulnerabilities);
        assert.strictEqual(sortedVulnerabilities?.[0].severity.value, 'High');
        assert.strictEqual(sortedVulnerabilities?.[1].severity.value, 'Medium');
        assert.strictEqual(sortedVulnerabilities?.[2].severity.value, 'Low');
    });
});